/*
 * Copyright (c) 2014. Knowledge Media Institute - The Open University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * NodeRed node with support for interaction with BLEs
 *
 * @author <a href="mailto:carlos.pedrinaci@open.ac.uk">Carlos Pedrinaci</a> (KMi - The Open University)
 * based on the initial node by Charalampos Doukas http://blog.buildinginternetofthings.com/2013/10/12/using-node-red-to-scan-for-ble-devices/
 */
module.exports = function(RED) {
    "use strict";

    var noble = require('noble');
    var os = require('os');
    
    // The main node definition - most things happen in here
    function NobleScan(n) {
        // Create a RED node
        RED.nodes.createNode(this,n);

        // Store local copies of the node configuration (as defined in the .html)
        this.duplicates = n.duplicates;
        this.isScan = n.isScan;
        this.localname  = n.localname;

        this.uuids = [];
        if (n.uuids != undefined && n.uuids !== "") {
            this.uuids = n.uuids.split(',');    //obtain array of uuids
        }

        var node = this;
        var machineId = os.hostname();
        var scanning = false;


        noble.on('discover', function(peripheral) {
            //console.log(111);
            peripheralObj = peripheral;
            if (node.isScan == true){
                var msg = { payload:{peripheralUuid:peripheral.uuid, localName: peripheral.advertisement.localName} };
                msg.peripheralUuid = peripheral.uuid;
                msg.localName = peripheral.advertisement.localName;
                msg.detectedAt = new Date().getTime();
                msg.detectedBy = machineId;
                msg.advertisement = peripheral.advertisement;
                msg.rssi = peripheral.rssi;

                // Check the BLE follows iBeacon spec
                if (peripheral.manufacturerData) {
                    // http://www.theregister.co.uk/2013/11/29/feature_diy_apple_ibeacons/
                    if (peripheral.manufacturerData.length >= 25) {
                        var proxUuid = peripheral.manufacturerData.slice(4, 20).toString('hex');
                        var major = peripheral.manufacturerData.readUInt16BE(20);
                        var minor = peripheral.manufacturerData.readUInt16BE(22);
                        var measuredPower = peripheral.manufacturerData.readInt8(24);

                        var accuracy = Math.pow(12.0, 1.5 * ((rssi / measuredPower) - 1));
                        var proximity = null;

                        if (accuracy < 0) {
                            proximity = 'unknown';
                        } else if (accuracy < 0.5) {
                            proximity = 'immediate';
                        } else if (accuracy < 4.0) {
                            proximity = 'near';
                        } else {
                            proximity = 'far';
                        }

                        msg.manufacturerUuid = proxUuid;
                        msg.major = major;
                        msg.minor = minor;
                        msg.measuredPower = measuredPower;
                        msg.accuracy = accuracy;
                        msg.proximity = proximity;
                    }
                }

                // Generate output event
                node.send(msg);
            }
            else{
                //console.log(333);

                if (peripheral.advertisement.localName == node.localname){
                    console.log('on -> discover: ' + peripheral);

                    noble.stopScanning();

                    peripheral.on('connect', function() {
                        console.log('on -> connect');
                        this.updateRssi();
                    });

                    peripheral.on('disconnect', function() {
                        console.log('on -> disconnect');
                    });

                    peripheral.on('rssiUpdate', function(rssi) {
                        console.log('on -> RSSI update ' + rssi);
                        this.discoverServices();
                    });

                    peripheral.on('servicesDiscover', function(services) {
                        console.log('on -> peripheral services discovered ' + services);

                        var serviceIndex = 0;
                        services[serviceIndex].on('includedServicesDiscover', function(includedServiceUuids) {
                            console.log('on -> service included services discovered ' + includedServiceUuids);
                            this.discoverCharacteristics();
                        });

                        services[serviceIndex].on('characteristicsDiscover', function(characteristics) {
                            console.log('on -> service characteristics discovered ' + characteristics);

                            var characteristicIndex = 0;

                            characteristics[characteristicIndex].on('read', function(data, isNotification) {
                                console.log('on -> characteristic read ' + data + ' ' + isNotification);
                                console.log(data);

                            if (data !='undefined'){

                                var msg = {};
                                //pedometer for walk
                                var idata = data.readUInt16LE(1,true); 
                                console.log('pedometer:'+idata);
                                msg["pedometer"]=idata;
                                
                                //distance
                                idata = data.readUInt16LE(3,true);
                                //idata = parseFloat(idata)/1000;
                                console.log('distance:'+idata);
                                if (idata > 0){
                                   msg["distance"]=idata;
                                }
                                else{
                                    msg["distance"]=-1;
                                }

                                
                                //power
                                idata = data.readUInt16LE(5,true);
                                //idata = parseFloat(idata)/1000;
                                console.log('power:'+idata);
                                msg["power"]=idata;

                                //yaw
                                idata = data.readUInt16LE(7,true); 
                                //idata = parseFloat(idata)/1000;
                                console.log('yaw:'+idata);
                                msg["yaw"]=idata;

                                //pitch
                                idata = data.readUInt16LE(9,true);
                                //idata = parseFloat(idata)/1000;
                                console.log('pitch:'+idata);
                                msg["pitch"]=idata;

                                //roll
                                idata = data.readUInt16LE(11,true);
                                //idata = parseFloat(idata)/1000;
                                console.log('roll:'+idata);
                                msg["roll"]=idata;
                                
                                var isvalid = true;
                                for(var i in msg){
                                    if (msg[i]<0){
                                        isvalid = false;
                                        break;
                                    }
                                }

                                console.log(isvalid);
                                
                                if (isvalid){
                                    node.send(msg);
                                    //msg = null;
                                }
                            }
                                

                            });

                            characteristics[characteristicIndex].on('write', function() {
                                console.log('on -> characteristic write ');

                                //peripheral.disconnect();
                            });

                            characteristics[characteristicIndex].on('broadcast', function(state) {
                                console.log('on -> characteristic broadcast ' + state);

                                peripheral.disconnect();
                            });

                            characteristics[characteristicIndex].on('notify', function(state) {
                                console.log('on -> characteristic notify ' + state);

                                peripheral.disconnect();
                            });

                            setInterval(function() {
                                characteristics[characteristicIndex].read();
                            }, 3000);
      
                           // characteristics[characteristicIndex].write(new Buffer([1,80,0]));

                            characteristicsEvent = characteristics[characteristicIndex];
                            
                            //characteristics[characteristicIndex].write(new Buffer('hello'));
                            //characteristics[characteristicIndex].broadcast(true);
                            //characteristics[characteristicIndex].notify(true);
                            // characteristics[characteristicIndex].discoverDescriptors();
                        });

                        services[serviceIndex].discoverIncludedServices();
                    });

                    peripheral.connect();
                }
            }
        });

        // Take care of starting the scan and sending the status message
        function startScan(stateChange, error) {
            if (!node.scanning) {
                // send status message
                var msg = {
                    statusUpdate: true,
                    error: error,
                    stateChange: stateChange,
                    state: noble.state
                };
                node.send(msg);
                // start the scan
                noble.startScanning(node.uuids, node.duplicates, function() {
                    node.log("Scanning for BLEs started. UUIDs: " + node.uuids + " - Duplicates allowed: " + node.duplicates);
                    node.status({fill:"green",shape:"dot",text:"started"});
                    node.scanning = true;
                });
            }
        }

        // Take care of stopping the scan and sending the status message
        function stopScan(stateChange, error) {
            if (node.scanning) {
                // send status message
                var msg = {
                    statusUpdate: true,
                    error: error,
                    stateChange: stateChange,
                    state: noble.state
                };
                node.send(msg);
                // stop the scan
                noble.stopScanning(function() {
                    node.log('BLE scanning stopped.');
                    node.status({fill:"red",shape:"ring",text:"stopped"});
                    node.scanning = false;
                });
                if (error) {
                    node.warn('BLE scanning stopped due to change in adapter state.');
                }
            }
        }

        // deal with state changes
        noble.on('stateChange', function(state) {
            console.log(222);
            if (state === 'poweredOn') {
                startScan(true, false);
            } else {
                if (node.scanning) {
                    stopScan(true, true);
                }
            }
        });

        // start initially
        if (noble.state === 'poweredOn') {
            startScan(false, false);
        } else {
            // send status message
            var msg = {
                statusUpdate: true,
                error: true,
                stateChange: false,
                state: noble.state
            };

            // TODO: Catch a global event instead eventually
            setTimeout(function(){
                node.send(msg);
            }, 3000);

            node.warn('Unable to start BLE scan. Adapter state: ' + noble.state);
        }

        noble.on('scanStart', function() {
           console.log('on -> scanStart');
        });

        noble.on('scanStop', function() {
           console.log('on -> scanStop');
        });

        // control scanning
        node.on('input', function (msg) {
            /*
            if (msg.hasOwnProperty("payload") && msg.payload == 'ON') {
                if (peripheralObj){
                    peripheralObj.connect();
                }
            }
            if (msg.hasOwnProperty("payload") && msg.payload == 'OFF') {
                if (peripheralObj){
                    peripheralObj.disconnect();
                }
            }

            if (msg.hasOwnProperty("walk")) {
                var buf_data = [1,msg.walk,0];
                if  (characteristicsEvent){
                    characteristicsEvent.write(new Buffer(buf_data));
                }
            }
            if (msg.hasOwnProperty("rotate")) {
                var buf_data = [1,0,msg.rotate];
                if  (characteristicsEvent){
                    characteristicsEvent.write(new Buffer(buf_data));
                }
            }

            if (msg.hasOwnProperty("stop")) {
                var buf_data = [1,0,0];
                if  (characteristicsEvent){
                    characteristicsEvent.write(new Buffer(buf_data));
                }
            }*/
            //node.warn("Incorrect input, ignoring. See the documentation in the info tab. ");
        });

    
        node.on("close", function() {
            if (peripheralObj){
                //peripheralObj.disconnect();
            }
            // Called when the node is shutdown - eg on redeploy.
            // Allows ports to be closed, connections dropped etc.
            // eg: this.client.disconnect();
            stopScan(false, false);
            // remove listeners since they get added again on deploy
            noble.removeAllListeners();
            //peripheralObj = null;
            //characteristicsEvent = null;
        });

    }
    
    // Register the node by name. This must be called before overriding any of the
    // Node functions.
    RED.nodes.registerType("xpd-noble",NobleScan);

}
